/*
This file contains a function to conduct InteGrative anaLysis with Optimal Weights (GLOW) using summary statistics (p-values)
Reference: Zhang, Hong, and Zheyang Wu. "The generalized Fisher's combination and accurate pâ€value
           calculation under dependence." Biometrics 79.2 (2023): 1159-1172.
           Liu, Ming. "Integrative Analysis of Large Genomic Data." WPI (2025).
Creators: Kylie Hoar
Last update (latest update first):
  KHoar 2025-04-23: Added comments and docstrings
*/

package is.hail.methods.gfisher

import breeze.linalg.{DenseMatrix => BDM, DenseVector => BDV}
import breeze.numerics._
import net.sourceforge.jdistlib.Normal

object GLOW_Omni_byP {

    /**
      * A variation of GLOW_Omni with input of summary statistics (p-values, z-scores, effect sizes, etc.)
      * Correlation structure is still needed, which could be estimated using reference panel genotype data if individual-level data is unavailable.
      *
      * Adapted from the GLOW R package ("GLOW_R_package/GLOW/R/GLOW_Omni_byP.R")
      * 
      * @param Zscores  Vector of Zscores, optional if p-values are given.
      * @param Pvalues  Vector of input p-values (two-sided), optional if Z-scores are given.
      * @param Effects  Vector of effect size for getting signs of the Z-scores. It matters for the Burden test. Optional if Zscores are given.
      * @param SE       Vector of standard errors
      * @param M        Variant correlation matrix, for example LD matrix from reference panel data.
      * @param B        A numeric vector of B (effect size) for estimating optimal weights.
      * @param PI       A numeric vector of PI (causal likelihood) for estimating optimal weights.
      *
      * @return         A Map object containing:
      *                     - "STAT": a list of GLOW statistics.
      *                     - "PVAL": the p-values of the involved tests.
      */
    def GLOW_Omni_byP (
        Zscores: Option[BDM[Double]] = None,
        Pvalues: Option[BDV[Double]] = None,
        Effects: Option[BDV[Double]],
        SE: BDV[Double],
        M: BDM[Double],
        B: BDV[Double],
        PI: BDV[Double]
    ): Map[String, BDM[Double]] = {

        // If Z-scores are not provided, compute them from input p-values and effect directions
        val finalZscores = Zscores.getOrElse {
            // Ensure effects are available to infer the direction of Z-scores.
            if (Effects.isEmpty) throw new IllegalArgumentException("Effect is required to get signs of Z scores for burden test")
            val Zsigns = signum(Effects.get)
            val PvaluesVec = Pvalues.getOrElse(throw new IllegalArgumentException("Pvalues is None"))
            PvaluesVec.map(p => Normal.quantile(1.0 - (p / 2.0), 0.0, 1.0, false, false)) *:* Zsigns
        }

        // Ensure final Z-scores are in vector form.
        val finalZscoresVec = finalZscores match {
            case v: BDV[Double] => v  // Already a DenseVector
            case m: BDM[Double] if m.cols == 1 => m.toDenseVector  // Convert single-column matrix to vector
            case _ => throw new IllegalArgumentException("finalZscores must be a DenseVector[Double]")
        }
        
        // Adjust effect sizes (B) by their standard errors (SE) (used for weighting).
        val Bstar = B /:/ SE // Element-wise division

        // Run the omnibus CCT test on the provided Z-scores (from input or generated by p-values)
        FuncCalcuCombTests.BSF_cctP_test(finalZscoresVec, M, Bstar, PI)
    }
}
